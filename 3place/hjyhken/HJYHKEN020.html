<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="hbaolong@vip.qq.com" />
  <title>黑客与画家EN:Appendix: Power</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">黑客与画家EN:Appendix: Power</h1>
<p class="author">hbaolong@vip.qq.com</p>
</header>
<center>
<a href="/3place/hjyhken">返回首页</a> <a
href="/3place/hjyhken/mingju.html">本书名句</a> <a
href="/3place/hjyhken/memo.html">本书注解</a> <a
href="/3place/hjyhken/index_rich.html">丰富目录</a> <a
href="/3place/hjyhken/index_readcal.html">同读日历</a> <a
href="/3place/hjyhken/index_timeline.html">时间线</a> <a
href="/3place/hjyhken/index_books.html">引用书籍</a> <a
href="/3place/hjyhken/index_words.html">使用字频</a>
<div id="wx_pic" style="margin:0 auto;display:none;">
<img src='/img/logo.png'/>
</div>
</center>
<h4 id="appendix-power">Appendix: Power</h4>
<p>As an illustration of what I mean about the relative power of
programming languages, consider the following problem. We want to write
a function that generates accumulators—a function that takes a number
n,and returns a function that takes another number i and returns n
incremented by i. (That’s incremented by, not plus. An accumulator has
to accumulate.)</p>
<p>In Common Lisp7 this would be:</p>
<p>(defun foo (n)</p>
<p>(lambda (i) (incf n i)))</p>
<p>In Ruby it’s almost identical:</p>
<p>def foo (n)</p>
<p>lambda {|i| n += i } end</p>
<p>Whereas in Perl 5 it’s</p>
<p>sub foo {</p>
<p>my () = <span class="citation" data-cites="_">@_</span>;</p>
<p>sub { += shift}</p>
<p>}</p>
<p>which has more elements than the Lisp/Ruby version because you have
to extract parameters manually in Perl.</p>
<p>In Smalltalk the code is also slightly longer than in Lisp and
Ruby:</p>
<p>foo: n</p>
<p>|s|</p>
<p>s := n.</p>
<p><a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<p>because although in general lexical variables work, you can’t do an
assignment to a parameter, so you have to create a new variable s to
hold the accumulated value.</p>
<p>In Javascript the example is, again, slightly longer, because
Javascript retains the distinction between statements and expressions,
so you need explicit return statements to return values:</p>
<p>function foo (n) {</p>
<p>return function (i) {</p>
<p>return n += i } }</p>
<p>(To be fair, Perl also retains this distinction, but deals with it in
typical Perl fashion by letting you omit returns.)</p>
<p>If you try to translate the Lisp/Ruby/Perl/Smalltalk/Javascript code
into Python you run into some limitations. Because Python doesn’t fully
support lexical variables, you have to create a data structure to hold
the value of n. And although Python does have a function data type,
there is no literal representation for one (unless the body is only a
single expression) so you need to create a named function to return.
This is what you end up with:</p>
<p>def foo (n):</p>
<p>s = [n]</p>
<p>def bar (i):</p>
<p>s[0] += i</p>
<p>return s[0]</p>
<p>return bar</p>
<p>Python users might legitimately ask why they can’t just write</p>
<p>def foo (n):</p>
<p>return lambda i: return n += i</p>
<p>or even</p>
<p>def foo (n):</p>
<p>lambda i: n += i</p>
<p>and my guess is that they probably will, one day. (But if they don’t
want to wait for Python to evolve the rest of the way into Lisp, they
could always just…)</p>
<p>In OO languages, you can, to a limited extent, simulate a closure (a
function that refers to variables defined in surrounding code) by
defining a class with one method and a field to replace each variable
from an enclosing scope. This makes the programmer do the kind of code
analysis that would be done by the compiler in a language with full
support for lexical scope, andit won’t work if more than one function
refers to the same variable, but it is enough in simple cases like
this.</p>
<p>Python experts seem to agree that this is the preferred way to solve
the problem in Python, writing either</p>
<p>def foo (n):</p>
<p>class acc:</p>
<p>def _ <em>init</em> _ (self, s):</p>
<p>self.s = s</p>
<p>def inc (self, i):</p>
<p>self.s += i</p>
<p>return self.s</p>
<p>return acc (n).inc</p>
<p>or</p>
<p>class foo:</p>
<p>def _ <em>init</em> _ (self, n):</p>
<p>self.n = n</p>
<p>def _ <em>call</em> _ (self, i):</p>
<p>self.n += i</p>
<p>return self.n</p>
<p>I include these because I wouldn’t want Python advocates to say I was
misrepresenting the language, but both seem to me more complex than the
first version. You’re doing the same thing, setting up a separate place
to hold the accumulator; it’s just a field in an object instead of the
head of a list. And the use of these special, reserved field names,
especially _ <em>call</em> _, seems a bit of a hack.</p>
<p>In the rivalry between Perl and Python, the claim of the Python
hackers seems to be that Python is a more elegant alternative to Perl,
but what this case shows is that power is the ultimate elegance: the
Perl program is simpler (has fewer elements), even if the syntax is a
bit uglier.</p>
<p>How about other languages? In the other languages mentioned
here—Fortran, C, C++, Java, and Visual Basic—it does not appear that you
can solve this problem at all. Ken Anderson says this is about as close
as you can get in Java:</p>
<p>public interface Inttoint {</p>
<p>public int call (int i);</p>
<p>}</p>
<p>public static Inttoint foo (final int n) {</p>
<p>return new Inttoint () {</p>
<p>int s = n;</p>
<p>public int call (int i) {</p>
<p>s = s + i;</p>
<p>return s;</p>
<p>}};</p>
<p>}</p>
<p>which falls short of the spec because it only works for integers.</p>
<p>It’s not literally true that you can’t solve this problem in other
languages, of course. The fact that all these languages are
Turing-equivalent means that, strictly speaking, you can write any
program in any of them. So how would you do it? In the limit case, by
writinga Lisp interpreter in the less powerful language.</p>
<p>That sounds like a joke, but it happens so often to varying degrees
in large programming projects that there is a name for the phenomenon,
Greenspun’s Tenth Rule:</p>
<p>Any sufficiently complicated C or Fortran program contains an ad hoc
informally-specified bug-ridden slow implementation of half of Common
Lisp.</p>
<p>If you try to solve a hard problem, the question is not whether you
will use a powerful enough language, but whether you will (a) use a
powerful language, (b) write a de facto interpreter for one, or (c)
yourself become a human compiler for one. We see this already beginning
to happen in the Python example, where we are in effect simulating the
code that a compiler would generate to implement a lexical variable.</p>
<p>This practice is not only common, but institutionalized. For example,
in the OO world you hear a good deal about “patterns.“ I wonder if these
patterns are not sometimes evidence of case (c), the human compiler, at
work.8 When I see patterns in my programs, I consider it a sign of
trouble. The shape of a program should reflect only the problem it needs
to solve. Any other regularity in the code is a sign, to me at least,
that I’m using abstractions that aren’t powerful enough—often that I’m
generating by hand the expansions of some macro that I need to
write.</p>
<h6 id="阅读日期-2026年01月16日-2026年01月16日-共-1-天">阅读日期：
2026年01月16日-2026年01月16日 共： 1 天</h6>
<script src="https://giscus.app/client.js"
        data-repo="hbaolong/hbaolong.github.io"
        data-repo-id="R_kgDOLetDQg"
        data-category="General"
        data-category-id="DIC_kwDOLetDQs4CfLEl"
        data-mapping="url"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>
<script src="https://giscus.app/client.js"
        data-repo="hbaolong/hbaolong.github.io"
        data-repo-id="R_kgDOLetDQg"
        data-category="General"
        data-category-id="DIC_kwDOLetDQs4CfLEl"
        data-mapping="url"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>:i| s := s+i. <a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
