<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="hbaolong@vip.qq.com" />
  <title>GITHUBEN:Chapter 1. Introduction</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">GITHUBEN:Chapter 1. Introduction</h1>
<p class="author">hbaolong@vip.qq.com</p>
</header>
<center>
<a href="/3place/githuben">返回首页</a> <a
href="/3place/githuben/mingju.html">本书名句</a> <a
href="/3place/githuben/memo.html">本书注解</a> <a
href="/3place/githuben/index_rich.html">丰富目录</a> <a
href="/3place/githuben/index_readcal.html">同读日历</a> <a
href="/3place/githuben/index_timeline.html">时间线</a> <a
href="/3place/githuben/index_books.html">引用书籍</a> <a
href="/3place/githuben/index_words.html">使用字频</a>
<div id="wx_pic" style="margin:0 auto;display:none;">
<img src='/img/logo.png'/>
</div>
</center>
<h4 id="chapter-1.-introduction">Chapter 1. Introduction</h4>
<p>The GitHub API is extremely comprehensive, permitting access and
modification of almost all data and metadata stored or associated with a
Git repository. Here is a summary of those sections ordered
alphabetically as they are on the GitHub API documentation site
(https://developer.github.com/v3/):</p>
<p>Activity: notifications of interesting events in your developer
life</p>
<p>Gists: programmatically create and share code snippets</p>
<p>Git Data: raw access to Git data over a remote API</p>
<p>Issues: add and modify issues</p>
<p>Miscellaneous: whatever does not fit into the general API
categorization</p>
<p>Organizations: access and retrieve organizational membership data</p>
<p>Pull Requests: a powerful API layer on the popular merge process</p>
<p>Repositories: modify everything and anything related to
repositories</p>
<p>Search: code driven search within the entire GitHub database</p>
<p>Users: access user data</p>
<p>Enterprise: specifics about using the API when using the private
corporate GitHub</p>
<p>In addition, though not a part of the API, there are other important
technologies you should know about when using GitHub which are not
covered in the API documentation:</p>
<p>Jekyll: hosting blogs and static documentation</p>
<p>Gollum: wikis tied to a repository</p>
<p>Hubot: a programmable chat robot used extensively at GitHub</p>
<p>With just one or two exceptions, Each of these sections of the GitHub
technology stack are covered in various chapters. The GitHub API
documentation is a stellar reference which you will use constantly when
writing any application that talks to the API, but the chapters in this
book serve a different purpose: these chapters are stories about
building applications on top of the technologies provided by GitHub.
Within these stories you will learn the tradeoffs and considerations you
will face when you use the GitHub API. Chapters in this book often cover
multiple pieces of the API when appropriate for the story we are
telling. We’ve generally tried to focus on a major API section and limit
exposure to other pieces as much as possible, but most chapters do need
to bring in small pieces of more than one section.</p>
<p>The “cURL” chapter: the chapter you are reading now covers a first
look at the API through the command line HTTP client called cURL. We
talk a bit about the response format and how to parse it within the
command line, and also document authentication.</p>
<p>The “Gist” chapter: covers the Gist API, as well as command line
tools and the Ruby language “Octokit” API client.</p>
<p>The “Gollum” chapter: explains usage of the Gollum command line tool
and associated Ruby library (gem) which is backed by Grit, the
C-language bindings for accessing Git repositories. We also document
some details of the Git storage format and how it applies to storing
large files inside of a Git repository, and show how to use the git
command line tools to play with this information.</p>
<p>The “Search” chapter: we build a GUI search app using Python.</p>
<p>The “Commit Status” chapter: our final chapter documents a relatively
new part of the API which documents the interactions between third party
tools and your code. This chapter builds an application using C# and the
Nancy .NET GitHub API libraries.</p>
<p>The “Jekyll” chapter: if you push a specifically organized repository
into GitHub, GitHub will host a fully featured blog, equivalent in most
ways to a Wordpress site (well, except for the complexity part). This
chapter documents how to format your repository, how to use Markdown
within Jekyll, how to use programmatic looping constructs provided by
Liquid Templates, and then shows how to import an entire web site from
the Internet Archive into the Jekyll format using Ruby. We show how to
respectfully spider a site using caching, a valuable technique when
using APIs or third party public information.</p>
<p>The “Android” chapter: in this chapter we create a mobile application
targeting the Android OS. Our application reads and writes information
into a Jekyll repository from the Git Data section of the API. We show
how to create user interface tests for Android which verify GitHub API
responses using the Calabash UI testing tool.</p>
<p>The “JavaScript” chapter: did you know you can host an entire “single
page application” on GitHub? We show how you can build an application
backed by a database called GitHub using the JavaScript language.
Importanly, we show how you can write a testable JavaScript application
that mocks out the GitHub API when needed.</p>
<p>The “Hubot” chapter: Hubot is a JavaScript (NodeJS) chat robot
enabling technologists to go beyond developer operations (“DevOps”) to a
new frontier called “ChatOps.” The Hubot chapter illustrates using the
Activities and Pull Requests section of the API. In addition we show how
you can simulate GitHub notifications and how to write testable Hubot
extensions (which is often a challenge when writing JavaScript
code).</p>
<p>We don’t cover the organization API: this is a small facet of the API
with only the ability to list organizations and modify metadata about
your organization; once you have used other parts of the API this nook
of the API will be very intuitive.</p>
<p>We also don’t cover the users section of the API. While you might
expect it to be an important part of the API, the users API is really
nothing more than an endpoint to list information about users, add or
remove SSH keys, adjust email addresses and modify your list of
followers.</p>
<p>There is not a specific chapter on issues. Historically GitHub used
to group issues and pull requests into the same API section, but with
the growing importance of pull requests they have separated them in the
API documentation. In fact, they are still internally stored in the same
database and pull requests are, at least for now, just another type of
issue. The Hubot chapter documents using pull requests and is a good
reference for issues in that way.</p>
<p>The enterprise API works almost exactly the same as the GitHub.com
site API. We don’t have a chapter telling a story about the enterprise
API, but we do provide an appendix which provides a few notes about how
to use it with a few API client libraries.</p>
<p>With these chapters we cover the entire API and hope to give you an
inside look into the inner workings of the brain of a developer building
on top of the GitHub API.</p>
<p>As you might have noticed, this book will take you on an exploration
of several different language clients for the GitHub API. Along the way,
we’ll point out the different idioms and methodologies inherent to those
client libraries and shed light on the darker corners of the GitHub API.
Don’t be alarmed if you thumb through the chapters and see a language
which you don’t know at all: each chapter is designed so that you can
follow along without intimacy to the language or toolkit. You will get
the most value if you install the language and associated tools, but the
story behind the projects we will build will be interesting even if you
don’t actually type a line of code from the chapter.</p>
<p>Enough of the theoretical: let’s jump into using the API with the
powerful cURL tool.</p>
<p>cURL: a starting point for API exploration</p>
<p>There will be times when you want to quickly access information from
the API without writing a formal program. Or, when you want to quickly
get access to the raw HTTP request headers and content. Or, where you
might even question the implementation of a client library and need
confirmation it is doing the right thing from another vantage point. In
these situations, cURL, a simple command line HTTP tool, is the perfect
fit. cURL, like the best unix tools, is a small program with a very
specific and purposefully limited set of features for accessing HTTP
servers.</p>
<p>cURL gives you the most naked vantage point you will find for the
GitHub API (barring using a network traffic analysis tool). cURL, like
the HTTP protocol which it speaks intimately, is stateless, meaning it
is challenging to use cURL to hit a service and then use the results
with a secondary request. We will use cURL in a later chapter within a
shell script that explores solutions to this problem, but note that cURL
works best with one-off requests.</p>
<p>Note</p>
<p>If you are running these examples on a Linux box, you should be able
use your native package management tool to install cURL - either a “sudo
yum install curl*” on a RedHat variant or “sudo apt-get install curl” on
an Ubuntu (or Debian) system. If you are on any recent version of OSX,
you already have cURL installed, but it you can’t find it, take a look
at the HomeBrew project (http://brew.sh/) or MacPorts project
(http://www.macports.org/). If you are running on Windows or another
operating system, you best bet is to download cURL from the cURL web
site here: http://curl.haxx.se/download.html</p>
<p>Let’s make a request. We’ll start with the most basic GitHub API
endpoint found at https://api.github.com.</p>
<p>$ curl https://api.github.com { “current_user_url“:
“https://api.github.com/user“, “current_user_authorizations_html_url“:
“https://github.com/settings/connections/applications{/client_id}“,
“authorizations_url“: “https://api.github.com/authorizations“,
“code_search_url“:
“https://api.github.com/search/code?q={query}{andandandandpage,per_page,sort,order}“,
“emails_url“: “https://api.github.com/user/emails“, “emojis_url“:
“https://api.github.com/emojis“, … }</p>
<p>We’ve abbreviated the response to make it more readable. A few
salient things to notice: there are a lot of URLs pointing to secondary
information, parameters are included in the URLs, and the response
format is JSON.</p>
<p>What can we learn from this API response?</p>
<p>Breadcrumbs to Successive API Paths</p>
<p>The GitHub API is a Hypermedia API. Though a discussion on what
constitutes hypermedia deserves an entire book of its own (Check out
O’Reilly’s “Hypermedia APIs with HTML5 and Node”), you can absorb much
of what makes hypermedia interesting by just looking at a response.
First, you can see from the API response above that by making a request
to the API, you actually get back a map of how you should make
additional responses. Not all clients use this information, of course,
but one goal behind Hypermedia APIs is that clients can dynamically
adjust their endpoints without recoding the client code. In other words,
the API should be able to adjust its map, and then clients will adjust
themselves, but you as the application developer using the client
libraries will not need to understand or even be aware of the changes.
If the thought of GitHub changing an API because clients should be
written to handle new endpoints automatically sounds worriesome, don’t
fret too much: GitHub is very dilligent about maintaining and supporting
their API in a way that most companies would do well to emulate. But,
you should know that you can rely on having a API reference inside the
API itself, rather than hosted externally in documentation which very
easily could turn out to be out of date with the API itself.</p>
<p>This map includes not just URLs, but also information about how to
provide parameters to the URLs. For example, the code_search_url key
references a URL which obviously allows you to search within code on
GitHub, but also tells you how to structure the parameters passed to
this URL. If you have an intelligent client who can follow this simple
format, you could dynamically generate the query without involving a
developer who can read API documentation. At least that is the dream
that Hypermedia points us to; if you are skeptical, at least know that
APIs such as GitHub encode documentation into themselves, and you can
bet GitHub has test coverage to prove that this documentation matches
the information delivered by the API endpoints. That’s a strong
guarantee that is sadly missing from many other APIs.</p>
<p>Now let’s briefly discuss the format of all GitHub API responses:
JSON.</p>
<p>The JavaScript Object Notation (JSON) Format</p>
<p>Every response you get back from the GitHub API will be in the JSON
format. JSON is a “lightweight data interchange format” (read more on
the JSON.org website). There are other competing and effective formats,
such as XML or YAML, but JSON is quickly becoming the defacto standard
for web services.</p>
<p>A few of the reasons why JSON is so popular:</p>
<p>JSON is readable: JSON has a nice balance of human readability when
compared to serialization formats like XML.</p>
<p>JSON can be used within JavaScript with very little modification (and
cognitive processing on the part of the programmer). A data format which
works equally well on both the client and server side was bound to be
victorious, as JSON has been.</p>
<p>You might expect that a site like GitHub, originally built on the
Ruby on Rails stack (and some of that code is still live), would support
specifying an alternative format like XML, but XML is no longer
supported. Long live JSON.</p>
<p>JSON is very straightforward if you have used any other text based
interchange format. One note about JSON that is not always obvious or
expected to people new to JSON: the format only supports using
double-quotes, not single-quotes.</p>
<p>We are using a command line tool, cURL, to retrieve data from the
API. It would be handy to have a simple command line tool that also
processes that JSON. Let’s talk about one such tool next.</p>
<p>Parsing JSON from the Command Line</p>
<p>JSON is a text format, so you could use any command line text
processing tool, such as the venerable AWK, to process JSON responses.
There is one fantastic JSON specific parsing tool which complements cURL
that is worth knowing: “jq”. If you pipe JSON content (using the |
character for most shells) into jq, you can then easily extract pieces
of the JSON using “filters.”</p>
<p>Note</p>
<p>jq can be installed from source, using package managers like brew or
apt-get, and there are binaries on the downloads page for OSX, Linux,
Windows and Solaris.</p>
<p>Going deeper, in the prior example, let’s pull out something
interesting from the API map that we receive when we access
api.github.com.</p>
<p>$ curl https://api.github.com | jq ‘.current_user_url’ % Total %
Received % Xferd Average Speed Time Time Time Current Dload Upload Total
Spent Left Speed 100 2004 100 2004 0 0 4496 0 –:–:– –:–:– –:–:– 4493
“https://api.github.com/user“</p>
<p>What just happened? The jq tool parsed the JSON, and using the
.current_user_url filter, it retrieved content from the JSON response.
If you look at the response again, you’ll notice it has key/value pairs
inside an associative array. It uses the current_user_url as a key into
that associative array and prints out the value there.</p>
<p>You also will notice that curl printed out transfer time information
(to standard error, so jq did not see it). If we want to restrict that
information and clean up the request we should use the -s switch, which
runs cURL in “silent” mode.</p>
<p>It should be easy to understand how the jq filter is applied to the
response JSON. For a more complicated request (for example, we might
want to obtain a list of public repositories for a user), we can see the
pattern for the jq pattern parameter emerging. Let’s get a more
complicated set of information, a user’s list of repositories and see
how we can extract information from the response using jq.</p>
<p>$ curl -s https://api.github.com/users/xrd/repos 〔 { “id“: 19551182,
“name“: “a-gollum-test“, “full_name“: “xrd/a-gollum-test“, “owner“: {
“login“: “xrd“, “id“: 17064, “avatar_url“:
“https://avatars.githubusercontent.com/u/17064?v=3“, … } 〕 $ curl -s
https://api.github.com/users/xrd/repos | jq ‘.〔0〕.owner.id’ 17064</p>
<p>This response is different structurally: instead of an associative
array, we now have an array (multiple items). To get the first one, we
specify a numeric index, and then key into the successive associative
arrays inside of it to reach the desired content: the owner id.</p>
<p>Jq is a great tool for checking the validity of JSON. As mentioned
before, JSON key/values are stored only with double-quotes, not single
quotes. You can verify that JSON is valid and satisfies this requirement
using jq.</p>
<p>$ echo ‘{ “a“ : “b“ }’ | jq ‘.’ { “a“: “b“ } $ echo “{ ‘no’ : ‘bueno’
}“ | jq “.“ parse error: Invalid numeric literal at line 1, column 7</p>
<p>The first JSON we pass into jq works, while the second, because it
uses invalid single quote characters, fails with an error. Jq filters
are strings passed as arguments, and the shell which provides the string
to jq does not care, however, if you use single quotes or double quotes,
as you see above. The echo command, if you didn’t already know, prints
out whatever string you provide to it; when we combine this with the
pipe character we can easily provide that string to jq through standard
input.</p>
<p>Jq is a powerful tool for quickly retrieving content from an arbitray
JSON request. Jq has many other powerful features, documented at
stedolan.github.io/jq.</p>
<p>We now know how to retrieve some interesting information from the
GitHub API and parse out bits of information from that response, all in
a single line. But, there will be times when you incorrectly specify
parameters to cURL or the API, and the data is not what you expect. Now
we’ll learn about how to debug the cURL tool and the API service itself
to provide more context when things go wrong.</p>
<p>Debugging Switches for cURL</p>
<p>As mentioned, cURL is a great tool when you are verifying that a
response is what you expect it to be. The response body is important,
but often you’ll want access to the headers as well. cURL makes getting
these easy with the -i and -v switches. The -i switch prints out request
headers, and the -v switch prints out both request and response headers
(the &gt; character indicates request data, and the &lt; character
indicates response data).</p>
<p>$ curl -i https://api.github.com HTTP/1.1 200 OK Server: GitHub.com
Date: Wed, 03 Jun 2015 19:39:03 GMT Content-Type: application/json;
charset=utf-8 Content-Length: 2004 Status: 200 OK X-RateLimit-Limit: 60
… { “current_user_url“: “https://api.github.com/user“, … } $ curl -v
https://api.github.com * Rebuilt URL to: https://api.github.com/ *
Hostname was NOT found in DNS cache * Trying 192.30.252.137… * Connected
to api.github.com (192.30.252.137) port 443 (#0) * successfully set
certificate verify locations: * CAfile: none CApath: /etc/ssl/certs *
SSLv3, TLS handshake, Client hello (1): * SSLv3, TLS handshake, Server
hello (2): … * CN=DigiCert SHA2 High Assurance Server CA * SSL
certificate verify ok. &gt; GET / HTTP/1.1 &gt; User-Agent: curl/7.35.0
&gt; Host: api.github.com &gt; Accept: <em>/</em> &gt; &lt; HTTP/1.1 200
OK * Server GitHub.com is not blacklisted …</p>
<p>With the -v switch you get everything: DNS lookups, information on
the SSL chain, and the full request and response information.</p>
<p>Note</p>
<p>Be aware that if you print out headers, a tool like jq will get
confused because you are no longer providing it with pure JSON.</p>
<p>This section shows us that there is interesting information not only
in the body (the JSON data) but also in the headers. It is important to
understand what headers are here and which ones are important. There are
a lot of them which the HTTP specification requires, and we can often
ignore those, but there are a few that are vital when you start making
more than just a few isolated request.</p>
<p>All The Headers and Data</p>
<p>Three headers are present in every GitHub API response which tell you
about the GitHub API rate limits. They are X-RateLimit-Limit,
X-RateLimit-Remaining, and X-RateLimit-Reset. These limits are explained
in detail in GitHub API Rate Limits.</p>
<p>The X-GitHub-Media-Type header contains information that will come in
handy when you are starting to retrieve text or blob content from the
API. when you make a request to the GitHub API you can specify the
format you want to work with by sending an Accept header with your
request.</p>
<p>Let’s look at the full response from the original request.</p>
<p>$ curl -i https://api.github.com/ HTTP/1.1 200 OK Server: GitHub.com
Date: Sat, 25 Apr 2015 05:36:16 GMT Content-Type: application/json;
charset=utf-8 Content-Length: 2004 Status: 200 OK X-RateLimit-Limit: 60
X-RateLimit-Remaining: 58 X-RateLimit-Reset: 1429943754 Cache-Control:
public, max-age=60, s-maxage=60 ETag: “a5c656a9399ccd6b44e2f9a4291c8289“
Vary: Accept X-GitHub-Media-Type: github.v3 X-XSS-Protection: 1;
mode=block X-Frame-Options: deny Content-Security-Policy: default-src
‘none’ Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: ETag, Link, X-GitHub-OTP,
X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset,
X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval
Access-Control-Allow-Origin: * X-GitHub-Request-Id:
C0F1CF9E:567A:9610FCB:553B27D0 Strict-Transport-Security:
max-age=31536000; includeSubdomains; preload X-Content-Type-Options:
nosniff Vary: Accept-Encoding X-Served-By:
13d09b732ebe76f892093130dc088652 { “current_user_url“:
“https://api.github.com/user“, “current_user_authorizations_html_url“:
“https://github.com/settings/connections/applications{/client_id}“,
“authorizations_url“: “https://api.github.com/authorizations“,
“code_search_url“:
“https://api.github.com/search/code?q={query}{andandandandpage,per_page,sort,order}“,
… “notifications_url“: “https://api.github.com/notifications“,
“organization_repositories_url“:
“https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}“,
“organization_url“: “https://api.github.com/orgs/{org}“,
“public_gists_url“: “https://api.github.com/gists/public“,
“rate_limit_url“: “https://api.github.com/rate_limit“, “repository_url“:
“https://api.github.com/repos/{owner}/{repo}“, … }</p>
<p>Using this map, is there anything interesting we can retrieve,
perhaps information about GitHub itself? We can use the organizational
URL and substitute “github” in the placeholder.</p>
<p>$ curl https://api.github.com/orgs/github { “login“: “github“, “id“:
9919, “url“: “https://api.github.com/orgs/github“, “repos_url“:
“https://api.github.com/orgs/github/repos“, “events_url“:
“https://api.github.com/orgs/github/events“, “members_url“:
“https://api.github.com/orgs/github/members{/member}“,
“public_members_url“:
“https://api.github.com/orgs/github/public_members{/member}“,
“avatar_url“: “https://avatars.githubusercontent.com/u/9919?v=3“,
“description“: “GitHub, the company.“, “name“: “GitHub“, “company“:
null, “blog“: “https://github.com/about“, “location“: “San Francisco,
CA“, “email“: “support@github.com“, “public_repos“: 106, “public_gists“:
0, “followers“: 0, “following“: 0, “html_url“:
“https://github.com/github“, “created_at“: “2008-05-11T04:37:31Z“,
“updated_at“: “2015-04-25T05:17:01Z“, “type“: “Organization“ }</p>
<p>You can see this tells us the company blog
(https://github.com/about), that the company is located in San
Francisco, and the creation date (which strangely does not match their
blog post which states April 10th was their official launch date:
https://github.com/blog/40-we-launched).</p>
<p>So far all of our requests have been to publicly available
information. But, the GitHub APi starts getting really interesting when
we authenticate and access private information and publicly inaccessible
services, like writing data to GitHub. We’ll discuss how and why you
want to use authentication next.</p>
<p>Authentication</p>
<p>There are two ways to authenticate when making a request to the
GitHub API: username and passwords (HTTP Basic), and oAuth tokens.</p>
<p>Username and Password Authentication</p>
<p>You can access protected content inside GitHub using a username and
password combination. Username authentication works by using the HTTP
Basic authentication supported by the -u flag in curl. HTTP Basic
Authentication is synonymous with username and password
authentication.</p>
<p>$ curl -u xrd https://api.github.com/rate_limit Enter host password
for user ‘xrd’: xxxxxxxx { “rate“: { “limit“: 5000, “remaining“: 4995,
“reset“: 1376251941 } }</p>
<p>This cURL command, authenticates into the GitHub API and then
retrieves information about our own specific rate limits for our user
account, protected information only available as a logged in user.</p>
<p>Benefits of Username Authentication</p>
<p>Almost any client library you use will support HTTP Basic
authentication. All the GitHub API clients we looked at support username
and passwords. And, writing your own specific client is easy as this is
a core feature of the HTTP standard, so if you use any standard HTTP
library when building your own client, you will be able to access
content inside the GitHub API.</p>
<p>Downsides to Username Authentication</p>
<p>There are many reasons why username and password authentication is
the wrong way to manage your GitHub API access.</p>
<p>HTTP Basic is an old protocol which never anticipated the granularity
of web services. It is not possible to specify only certain features of
a web service if you ask users to authenticate with
username/passwords.</p>
<p>If you use a username and password to access GitHub API content from
your cell phone, and then access API content from your laptop, you have
no way to block access to one without blocking the other.</p>
<p>HTTP Basic authentication does not support extensions to the
authentication flow. Many modern services now support two-factor
authentication and there is no way to inject this into the process
without changing the HTTP clients (web browsers, for example) or at
least the flow they expect (making the browser repeat the request).</p>
<p>All of these problems are solved (or at least supported) with oAuth
flows. For these reasons, there are very few reasons to use username and
passwords. If you do need simple and quick access to the GitHub API (and
you don’t use two factor authentication) then HTTP basic authentication
can help you in a small subset of use cases.</p>
<p>oAuth</p>
<p>oAuth is an authentication mechanism where tokens are tied to
functionality or clients. In other words, you can specify what features
of a service you want to permit an oAuth token to carry with it, and you
can issue multiple tokens and tie those to specific clients: a cell
phone app, a laptop, a smart watch, or even an Internet of Things
toaster. And, importantly, you can revoke tokens without impacting other
tokens.</p>
<p>The main downside to oAuth tokens is that they introduce a level of
complexity that you may not be familiar with if you have only used HTTP
Basic which generally only requires an extra header to the HTTP request,
or an extra flag to a client tool like cURL.</p>
<p>oAuth solves the problems described above by linking tokens to scopes
(specified subsets of functionality inside a webs service) and issuing
as many tokens as you need to multiple clients.</p>
<p>Scopes: specified actions tied to authentication tokens</p>
<p>When you generate an oAuth token, you specify the access rights you
require. Don’t be confused because we start with HTTP Basic to generate
the oAuth token: once you have the token, you no longer need to use HTTP
Basic in successive requests. If this token is properly issued, the
oAuth token will have permissions to read and write to public
repositories owned by that user.</p>
<p>$ curl -u username -d ‘{“scopes“:〔“public_repo“〕}’
https://api.github.com/authorizations { “id“: 1234567, “url“:
“https://api.github.com/authorizations/1234567“, “app“: { “name“: “My
app“, “url“: “https://developer.github.com/v3/oauth_authorizations/“,
“client_id“: “00000000000000000000“ }, “token“: “abcdef87654321 … }</p>
<p>The JSON response, upon success, has a token you can extract and use
for applications that need access to the GitHub API.</p>
<p>If you are using two factor authentication, this flow requires
additional steps, all of which are documented within the 〔Link to
Come〕.</p>
<p>To use this token, you specify the token inside an authorization
header. It is a little bit early to talk about exactly how to interact
with the API, but the syntax in cURL looks like the following. For a
full flow, check out the Hubot chapter which shows how to use cURL with
an oAuth token.</p>
<p>$ curl -H “Authorization: token abcdef87654321“ …</p>
<p>Scopes clarify how a service or application will use data inside the
GitHub API. This makes it easy to audit how you are using the
information if this was a token issued for your own personal use. But,
most importantly, this provides valuable clarity and protection for
those times when a third party application wants to access your
information: you can be assured the application is limited in what data
it can access, and you can revoke access easily.</p>
<p>Scope Limitations</p>
<p>There is one major limitation of scopes to be aware of: you cannot do
fine-grained access to certain repositories only. If you provide access
to any of your private repositories, you are providing access to all
repositories.</p>
<p>It is likely that GitHub will change the way scopes work and address
some of these issues. The great thing about the way oAuth works is that
to support these changes you will simply need to request a new token
with the scope modified, but otherwise, the application authentication
flow will be unchaged.</p>
<p>Warning</p>
<p>Be very careful about the scopes you request when building a service
or application. Users are (rightly) paranoid about the data they are
handing over to you, and will evaluate your application based on the
scopes requested. If they don’t think you need that scope, be sure to
remove it from the list you provide to GitHub when authorizing and
consider escalation to a higher scope after you have developed some
trust with your users.</p>
<p>Scope Escalation</p>
<p>You can ask for scope at one point which is very limited, and then
later ask for a greater scope. For example, when a user first accesses
your application, you could only get the user scope to create a user
object inside your service, and only when your application needs
repository information for a user, then request to escalate privileges.
At this point the user will need to approve or disapprove your request,
but asking for everything up front (before you have a relationship with
the user) often results in a user abandoning the login.</p>
<p>Simplified oAuth Flow</p>
<p>oAuth has many variants, but GitHub uses oAuth2. oAuth2 specifies a
flow where:</p>
<p>the application requests access</p>
<p>the service provider (GitHub) requests authentication: username and
password usually.</p>
<p>if two-factor authentication is enabled, ask for the OTP (one time
password) code.</p>
<p>GitHub responds with a token inside a JSON payload</p>
<p>the application uses the oAuth token to make requests of the API.</p>
<p>A real world flow is described in full in the 〔Link to Come〕.</p>
<p>Now let’s review an important fundamental when using web services,
the importance of the HTTP status code.</p>
<p>Status Codes</p>
<p>The GitHub API uses HTTP status codes to tell you definitive
information about how your request was processed. If you are using a
basic client like cURL, it will be important to validate the status code
before you look at any of the data retrieved. If you are writing your
own API client, pay close attention to the status code before anything
else.</p>
<p>Success (200 or 201)</p>
<p>If you have worked with any HTTP clients whatsoever, you know what
the HTTP status code “200” means success. GitHub will respond with a 200
status code when your request destination URL and associated parameters
are correct. If your request creates content on the server, then you
will get a 201 status code, indicating a successful creation on the
server.</p>
<p>$ curl -s -i https://api.github.com | grep Status Status: 200 OK</p>
<p>Naughty JSON (400)</p>
<p>If your payload (the JSON you send to a request) is invalid, the
GitHub API will respond with a 400 error, as shown below.</p>
<p>$ curl -i -u xrd -d ‘yaml: true’ -X POST https://api.github.com/gists
Enter host password for user ‘xrd’: HTTP/1.1 400 Bad Request Server:
GitHub.com Date: Thu, 04 Jun 2015 20:33:49 GMT Content-Type:
application/json; charset=utf-8 Content-Length: 148 Status: 400 Bad
Request … { “message“: “Problems parsing JSON“, “documentation_url“:
“https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization“
}</p>
<p>Here we attempt to generate a new gist by using the endpoint
described at the Gist API documentation:
https://developer.github.com/v3/gists/#create-a-gist. We’ll detail Gists
in more detail in a later chapter. This issue fails because we are not
using JSON (this looks it could be YAML, which we will discuss in the
Jekyll chapter). The payload is sent using the -d switch. GitHub
responds with advice on where to find the documentation for the correct
format at the documentation_url key inside the JSON response. Notice
that we use the -X POST switch and value to tell cURL to make a POST
request to GitHub.</p>
<p>Improper JSON (422)</p>
<p>If any of the fields in your request are invalid, GitHub will respond
with a 422 error. Let’s attempt to fix the previous request. The
documentation indicates the JSON payload should look like this:</p>
<p>{ “description“: “the description for this gist“, “public“: true,
“files“: { “file1.txt“: { “content“: “String file contents“ } } }</p>
<p>What happens if the JSON is valid, but the fields are incorrect?</p>
<p>curl -i -u chris@burningon.com -d ‘{ “a“ : “b“ }’ -X POST
https://api.github.com/gists Enter host password for user
‘chris@burningon.com’: HTTP/1.1 422 Unprocessable Entity … { “message“:
“Invalid request.</p>
<p>“files“ wasn’t supplied.“, “documentation_url“:
“https://developer.github.com/v3“ }</p>
<p>There are two important things to note: first, we get a 422 error,
which indicates the JSON was valid, but the fields were incorrect. We
also get a response which indicates why: we are missing the files key
inside the request payload.</p>
<p>Successful Creation (201)</p>
<p>Now, let’s use valid JSON and see what happens:</p>
<p>$ curl -i -u xrd  -d
‘{“description“:“A“,“public“:true,“files“:{“a.txt“:{“content“:“B“}}}
 https://api.github.com/gists Enter host password for user ’xrd’:
HTTP/1.1 201 Created … { “url“:
“https://api.github.com/gists/4a86ed1ca6f289d0f6a4“, “forks_url“:
“https://api.github.com/gists/4a86ed1ca6f289d0f6a4/forks“,
“commits_url“:
“https://api.github.com/gists/4a86ed1ca6f289d0f6a4/commits“, “id“:
“4a86ed1ca6f289d0f6a4“, “git_pull_url“:
“https://gist.github.com/4a86ed1ca6f289d0f6a4.git“, … }</p>
<p>Success! We created a gist and got a 201 status code indicating
things worked properly. To make our command more readable we used the
backslash character to allow parameters to span across lines. Also,
notice the JSON does not require whitespace which we have completely
removed from the string passed to the -d switch (in order to save space
and make this command a little bit more readable).</p>
<p>Nothing Has Changed (304)</p>
<p>304s are like 200s in that they say to the client: yes, your request
succeeded. They give a little bit of extra information, however, in that
they tell the client that the data has not changed since the last time
the same request was made. This is valuable information if you are
concerned about your usage limits (and in most cases you will be). You
need to trigger 304s manually by adding conditional headers to your
request.</p>
<p>Conditional Requests to Avoid Rate Limitations</p>
<p>If you are querying the GitHub APIs to obtain activity data for a
user or a repository, there’s a good chance that many of your requests
won’t return much activity. If you check for new activity once every few
minutes, there will be time periods over which no activity has occurred.
These requests, these constant polls still use up requests in your rate
limit even though there’s no new activity to be delivered.</p>
<p>In these cases, you can send conditional HTTP headers
If-Modified-Since and If-None-Match to tell GitHub to return an HTTP 304
response code telling you that nothing has been modified. When you send
a request with a conditional header and the GitHub API responds with a
HTTP 304 response code, this request is not deducted from your rate
limit.</p>
<p>The following command listing is an example of passing in the
If-Modified-Since HTTP header to the GitHub API. Here we’ve specified
that we’re only interested in receiving content if the Twitter Boostrap
repositories has been altered after 7:49 PM GMT on Sunday, August 11,
2013. The GitHub API responds with a HTTP 304 response code which also
tells us that the last time this repository changed was a minute earlier
than our cutoff date.</p>
<p>$ curl -i https://api.github.com/repos/twbs/bootstrap  -H
“If-Modified-Since: Sun, 11 Aug 2013 19:48:59 GMT“ HTTP/1.1 304 Not
Modified Server: GitHub.com Date: Sun, 11 Aug 2013 20:11:26 GMT Status:
304 Not Modified X-RateLimit-Limit: 60 X-RateLimit-Remaining: 46
X-RateLimit-Reset: 1376255215 Cache-Control: public, max-age=60,
s-maxage=60 Last-Modified: Sun, 11 Aug 2013 19:48:39 GMT</p>
<p>The GitHub API also understands HTTP caching tags. An ETag, or Entity
Tag, is an HTTP header that is used to control whether or not content
that you have previously cached is the most recent version. Here’s how
your systems would use ETag:</p>
<p>Your server requests information from an HTTP server.</p>
<p>Server returns an ETag header for a version of a content item.</p>
<p>Your server includes this ETag in all subsequent requests.</p>
<p>If the server has a newer version it returns new content + a new
ETag</p>
<p>If the server doesn’t have a newer version it returns an HTTP 304</p>
<p>The following command listing demonstrates to commands. The first
curl call to the GitHub API generates an ETag value, and the second
value passes this ETag value as an If-None-Match header. You’ll note
that the second response is an HTTP 304 which tells the caller that
there is no new content available.</p>
<p>$ curl -i https://api.github.com/repos/twbs/bootstrap HTTP/1.1 200 OK
Cache-Control: public, max-age=60, s-maxage=60 Last-Modified: Sun, 11
Aug 2013 20:25:37 GMT ETag: “462c74009317cf64560b8e395b9d0cdd“ { “id“:
2126244, “name“: “bootstrap“, “full_name“: “twbs/bootstrap“, …. } $ curl
-i https://api.github.com/repos/twbs/bootstrap  -H ‘If-None-Match:
“462c74009317cf64560b8e395b9d0cdd“’ HTTP/1.1 304 Not Modified Status:
304 Not Modified Cache-Control: public, max-age=60, s-maxage=60
Last-Modified: Sun, 11 Aug 2013 20:25:37 GMT ETag:
“462c74009317cf64560b8e395b9d0cdd“</p>
<p>If you are developing an application that needs to make a significant
number of requests to the GitHub API over a long period of time, you can
use a caching HTTP proxy like Squid to take care of automatically
caching content, storing content alongside ETags, and injecting the
“If-None-Match” header into GitHub API requests. If you do this, you’ll
be automating the injection of conditional headers and helping to reduce
the overall load on the GitHub API.</p>
<p>Use of conditional request headers is encouraged to conserve
resources and make sure that the infrastructure that supports GitHub’s
API isn’t asked to generated content unnecessarily.</p>
<p>You might now be wondering: what are my rate limits and when should I
care about them?</p>
<p>GitHub API Rate Limits</p>
<p>GitHub tries to limit the rate at which users can make requests to
the API. Anonymous requests, requests that haven’t authenticated with
either a username/password or OAuth information, are limited to 60
requests an hour. If you are developing a system to integrate with the
GitHub API on behalf of users, clearly 60 requests per hour isn’t going
to be sufficient.</p>
<p>This rate limit is increased to 5000 requests per hour if you are
making an authenticated request to the GitHub API, and while this rate
is two orders of magnitude larger than the anonymous rate limit, it
still presents problems if you intend to use your own GitHub credentials
when making requests on behalf of many users.</p>
<p>For this reason, if your web site or service uses the GitHub API to
request information from the GitHub API, you should consider using OAuth
and make requests to the GitHub API using your user’s shared
authentication information.</p>
<p>Note</p>
<p>There are actually two rate limits. The “core” rate limit and the
“search” rate limit. The rate limits explained in the previous
paragraphs were for the core rate limit. For search, requests are
limited at 20 requests per minute for authenticated user requests and 5
request per minute for anonymous requests. The assumption here is that
search is a more infrastructure intensive request to satisfy and that
tighter limits are placed on its usage.</p>
<p>Note that GitHub tracks anonymous requests by IP address. This means
that if you are behind a firewall with other users making anonymous
requests, all those requests will be grouped together.</p>
<p>Reading Your Rate Limits</p>
<p>Reading your rate limit is straightforward, just make a GET request
to /rate_limit. This will return a JSON document which tells you the
limit you are subject to, the number of requests you have remaining, and
the timestamp (in seconds since 1970). Note that this timestamp has a
timezone in Coordinated Universal Time (UTC).</p>
<p>The following command listing uses curl to retrieve the rate limit
for an anonymous request. This response is abbreviated to save space in
this book, but you’ll notice that the quota information is supplied
twice: once in the HTTP response headers and again in the JSON response.
The rate limit headers are returned with every request to the GitHub
API, so there is little need to make a direct call to the /rate_limit
API.</p>
<p>$ curl https://api.github.com/rate_limit { “resources“: { “core“: {
“limit“: 60, “remaining“: 48, “reset“: 1433398160 }, “search“: {
“limit“: 10, “remaining“: 10, “reset“: 1433395543 } }, “rate“: {
“limit“: 60, “remaining“: 48, “reset“: 1433398160 } }</p>
<p>60 requests over the course of an hour isn’t very much, and if you
plan on doing anything interesting, you will likely exceed this limit
quickly. If you are hitting up against the 60 requests per minute limit,
you will likely want to investigate making authenticated requests to the
GitHub API. We’ll show that when we discuss authenticated requests.</p>
<p>Note</p>
<p>Calls to the Rate Limit API are not deducted from your Rate Limit.
Isn’t that nice of them?</p>
<p>At this point we have been accessing the GitHub API from a cURL
client, and as long as our network permits it, we can do whatever we
want. The GitHub API is accessible in other situations as well, like
from within a browser context, and certain restrictions apply there, so
let’s discuss that next.</p>
<p>Accessing Content from the Web</p>
<p>If you are using the GitHub API from a server side program or the
command line then you are free to issue any network calls as long as
your network permits it. If you are attempting to access the GitHub API
from within a browser using JavaScript and the XHR (XmlHttpRequest)
object, then you should be aware of limitations imposed by the browser’s
same-origin policy. In a nutshell, you are not able to access domains
from JavaScript using standard XHR requests outside of the domain from
which you retrieved the original page. There are two options for getting
around this restriction, one clever (JSON-P) and one fully supported but
slightly more onerous (CORS).</p>
<p>JSON-P</p>
JSON-P is a browser hack, more or less, that allows retrieval of
information from servers outside of the same-origin policy. JSON-P works
because
<script> tags are not checked against the same-origin policy; in other words, you can specify your page should load scripts from any domain and the browser will permit it. With JSON-P, you load a JavaScript file which resolves to a specially encoded data payload wrapped in a callback function you implement. The GitHub API supports this syntax: you request a script with a parameter on the URL indicating what callback you want the script to execute once loaded.

We can simulate this request in cURL:

$ curl https://api.github.com/?callback=myCallback /**/myCallback({ “meta“: { “X-RateLimit-Limit“: “60“, “X-RateLimit-Remaining“: “52“, “X-RateLimit-Reset“: “1433461950“, “Cache-Control“: “public, max-age=60, s-maxage=60“, “Vary“: “Accept“, “ETag“: “\“a5c656a9399ccd6b44e2f9a4291c8289\““, “X-GitHub-Media-Type“: “github.v3“, “status“: 200 }, “data“: { “current_user_url“: “https://api.github.com/user“, “current_user_authorizations_html_url“: “https://github.com/settings/connections/applications{/client_id}“, “authorizations_url“: “https://api.github.com/authorizations“, ... } })

If you used the same URL we used above inside a script tag on a web page (<script src=“https://api.github.com/?callback=myCallback“ type=“text/javascript“></script>
<p>), your browser would load the content displayed above, and then a
JavaScript function you defined called myCallback would be executed with
the data shown. This function could be implemented like this inside your
web page.</p>
<script> function myCallback( payload ) { if( 200 == payload.status ) { document.getElementById(“success“).innerHTML = payload.data.current_user_url; } else { document.getElementById(“error“).innerHTML = “An error occurred“; } } </script>
This example demonstrates taking the current_user_url from the data
inside the payload and putting it into a DIV, one that might look like
<div id="“success“">

</div>
<p>.</p>
Because JSON-P works via
<script> tags, only GET requests to the API are supported. If you only need read-only access to the API, JSON-P can fulfill that need in many cases, and it is easy to configure.

If JSON-P seems too limiting or hackish, CORS is a more complicated but official way to access external services from within a web page.

CORS Support

CORS is the “correct” way to access GitHub content from within a browser context. CORS requires that the server be properly configured in advance; the server must be indicate when queried that it allows cross domain requests. If the server effectively says “yes, you can access my content from a different domain” then CORS requests are permitted. The HTML5Rocks website has a great tutorial explaining many details of CORS: http://www.html5rocks.com/en/tutorials/cors/.

Because XHR using CORS allows the same type of XHR requests as you get from the same domain origin, you can make requests beyond GET to the GitHub API: POST, DELETE and UPDATE. Between JSON-P and CORS there are options to retrieve content from the GitHub API. The choice is between the simplicity of JSON-P and the power and extra configuration of CORS.

We can prove using cURL that the GitHub API server is responding correctly for CORS request. In this case we only care about the headers, so we use the -I switch which tells cURL to make a HEAD request, telling the server not to respond with body content.

curl -I https://api.github.com HTTP/1.1 200 OK Server: GitHub.com ... X-Frame-Options: deny Content-Security-Policy: default-src 'none' Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: ETag, Link, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval Access-Control-Allow-Origin: * X-GitHub-Request-Id: C0F1CF9E:07AD:3C493B:557107C7 Strict-Transport-Security: max-age=31536000; includeSubdomains; preload

We can see the “Access-Control-Allow-Credentials” header is set to true. It depends on the browser implementation, but some JavaScript host browsers will automatically make a “preflight” request to verify this header is set to true (and that other headers, like the “Access-Control-Allow-Origin” are set correctly and permit requests from that origin to proceed). Other JavaScript host browsers will need you to make that request. Once the browser has used the headers to confirm that CORS is permitted, you can make XHR requests to the GitHub API domain as you would any other XHR request going into the same domain.

We’ve covered much of the details of connecting and dissecting the GitHub API, but there are a few other options to know about when using it. One of them is that you can use the GitHub API service to provide rendered content when you need it.

Specifying Response Content Format

When you send a request to the GitHub API, you have some ability to specify the format of the response you expect. For example, if you are requesting content that contains text from a commit’s comment thread, you can use the Accept header to ask for the raw markdown or for the HTML this markdown generates. You also have the ability to specify this version of the GitHub API you are using. At this point, you can specify either version 3 or beta of the API.

Retrieving Formatted Content

The Accept header you send with a request can affect the format of text returned by the GitHub API. As an example, let’s assume you wanted to read the body of a GitHub Issue. An issue’s body is stored in markdown and will be sent back in the request by default. If we wanted to render the response as HTML instead of markdown, we could do this by sending a different accept header, as the following cURL commands demonstrate.

$ URL='https://api.github.com/repos/rails/rails/issues/11819' $ curl -s  | jq '.body' “Hi, 



I have a problem with strong....“ # $ curl -s  | jq '.body_html' null # $ curl -s  \ -H “Accept: application/vnd.github.html+json“ | jq '.body_html' “<p>Hi, </p>

<p>I have a problem with...“ #

Without specifying an extra header, we get the internal representation of the data, sent as markdown.

Note that if we don’t request the HTML representation, we don’t see it in the JSON by default.

If we use a customized accept header like in the third instance, then our JSON is populated with a rendered version of the body in HTML.

Besides “raw” and “html” there are two other format options that influence how Markdown content is delivered via the GitHub API. If you specify “text” as a format, the issue body would have been returned as plaintext. If you specify “full” then the content will be rendered multiple times including the raw Markdown, rendered HTML, and rendered plaintext.

In addition to controlling the format of text content, you can also retrieve GitHub blobs either as raw binary or as a BASE64 encoded text. When retrieving commits, you can also specify that the content be returned either as a diff or as a patch. For more information about these fine-grained controls for formatting, see the GitHub API documentation.

Before you start building a system atop another service’s API, it is always wise to understand what, if any, limitations are placed on that API’s usage. Aside from the limitations on bandwidth, GitHub’s API is also covered by the overall GitHub Terms of Service. You can read these terms of service here: https://help.github.com/articles/github-terms-of-service

GitHub Has Amazing API Documentation

The GitHub team has already provided very thorough documentation on their API with examples using cURL. Bookmark this URL: https://developer.github.com/v3/. You’ll use it often. Do note that this URL is tied, obviously, to the current API “Version 3”, so this URL will change when a new version is released.

Summary

In this chapter we learned how to access the GitHub API from the simplest client available: the command line cURL HTTP tool. We also explored the API by looking at the JSON and played with a command line tool (jq) that when paired with cURL gives us the ability to quickly find information in the often large body of data the GitHub API provides. We learned about the different authentication schemes supported by GitHub, and also learned about the possibilities and tradeoffs when accessing the GitHub API from within a browser context.

In the next chapter we will look at Gists and the Gist API. We’ll use Ruby to build a Gist display program, and host all source files for the application as a Gist itself.


###### 阅读日期： 2025年11月19日-2025年11月19日  共： 1 天
<script src="https://giscus.app/client.js"
        data-repo="hbaolong/hbaolong.github.io"
        data-repo-id="R_kgDOLetDQg"
        data-category="General"
        data-category-id="DIC_kwDOLetDQs4CfLEl"
        data-mapping="url"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>
</body>
</html>
