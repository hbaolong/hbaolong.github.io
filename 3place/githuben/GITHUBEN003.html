<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="hbaolong@vip.qq.com" />
  <title>GITHUBEN:Chapter 2. Gists and the Gist API</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">GITHUBEN:Chapter 2. Gists and the Gist API</h1>
<p class="author">hbaolong@vip.qq.com</p>
</header>
<center>
<a href="/3place/githuben">返回首页</a> <a
href="/3place/githuben/mingju.html">本书名句</a> <a
href="/3place/githuben/memo.html">本书注解</a> <a
href="/3place/githuben/index_rich.html">丰富目录</a> <a
href="/3place/githuben/index_readcal.html">同读日历</a> <a
href="/3place/githuben/index_timeline.html">时间线</a> <a
href="/3place/githuben/index_books.html">引用书籍</a> <a
href="/3place/githuben/index_words.html">使用字频</a>
<div id="wx_pic" style="margin:0 auto;display:none;">
<img src='/img/logo.png'/>
</div>
</center>
<h4 id="chapter-2.-gists-and-the-gist-api">Chapter 2. Gists and the Gist
API</h4>
<p>GitHub revolutionized software development by responding to a deep
desire to share information. But calling it just “sharing” does a
disservice to the tools GitHub provides: these tools remove barriers to
communication and streamline workflows and these tools also arose at
exactly the moment when more and more companies permitted and more and
more complementary technologies appeared to allow an emerging remote
workforce. Gists service part of this need: they permit intimate code
sharing and reuse, refactoring and play in a way not served by
heavyweight tools predating it.</p>
<p>Gists are easy to create and the interface is stripped down to the
barest level. You add a snippet of code and then share the URL. Gists
autodetect the language in most cases and format it correctly. Gists can
be used in more powerful ways than might appear at first glance and this
chapter will explore other ways to share code and amplify your team.</p>
<p>To create a gist, go to gist.github.com and enter in any textual
data. You then choose public or secret access and create the gist. After
creating the gist, you receive a shareable URL with the code. If the
type of textual data is specified, usually the coding language type,
then the code will be formatted in a pretty way for better readability.
If you need to share a small bit of code, or write something and discuss
it, gists are a great tool.</p>
<p>There are other services that do this: pastebin was the first, and
there are many others that offer variances on code sharing. But gists by
GitHub are not simply a pasting service. Gists are first class
repositories, forkable, editable and expansive. We’ll go over the basics
of what gists are, and how to create them, and then show how they allow
you to share code that is also a live application.</p>
<p>Gists are repositories</p>
<p>Every gist created is a tiny repository. You can update gists and see
the history using git log. You can download gists, hack on the
repository, and git push them back into the repository on
gist.github.com (which will republish them onto the publicly facing web
page). And, you can “fork” gists, just like any other repository.</p>
<p>You are allowed to branch within gist repositories; however, branches
are not displayed inside of gist.github.com. But, if you need the
benefits of branching when using GitHub gists you can branch normally
inside a repository and keep the branch information on the upstream
repository after you push it up.</p>
<p>You can have an unlimited number of public and secret gists. Instead
of creating a new private repository from your limited amount in a paid
GitHub account, you can take a tiny bit of code and make a secret gist,
sharing this with others through a URL instead of the more onerous
process of adding collaborators to a regular repository. Or, you can
make a gist public, and share that URL to mailing lists or anywhere you
need public feedback.</p>
<p>Note</p>
<p>As there are two types of gists (public and secret), it is important
the understand the differences between them. Public gists are
searchable. Secret gists are not searchable, but they are accessible to
anyone who knows the URL. Don’t post any code to gist which you need to
keep secret as once you put it there, it is only as safe as the URL is
secret.</p>
<p>Most people share gists through the URL. But, you can embed gists
inside of other contexts (like blogs) and get a simple and pretty
snippet of code.</p>
<p>Embedding Gists Inside HTML</p>
To embed inside of an HTML page look for the “Embed this gist” box to
the left of a gist. Copy the code listed there (which will look
something like
<script src=“https://gist.github.com/xrd/8923697.js“></script>
<p>and paste it into your HTML.</p>
<p>If you wish to include only a particular file from the Gist (if it
contains multiple files), then add ?file=hi.rb to the end of the URL
specified in the src attribute.</p>
<p>Embedding Inside Jekyll blogs</p>
<p>Though we have not yet explained how Jekyll works (the GitHub
blogging tool), it seems valid to point out the ease in which you can
publish gists into a blog if that blog happens to be Jekyll hosted on
GitHub.</p>
<p>Jekyll supports a fast shortcut code to embed a public gist inside of
your Jekyll blog hosted on GitHub, or on any site built on the
“github-pages” branch mechanism (described in the Chapter 6 chapter).
The shortcut {% gist 8138797 %} will embed a private gist which would be
found at http://gist.github.com/8138797.</p>
<p>If you want to use a specific file within the gist, add a filename to
the gist code like {% gist 8138797 hi.rb %}.</p>
<p>Secret gists can also be embedded. If you use a secret gist, prefix
the username of the account holder in the gist like so: {% gist
xrd/8138797 hi.rb %}.</p>
<p>Gist from the command line</p>
<p>gem install gist will install a command line tool which assists in
creating gists. You can use it simply by typing the command, and then
entering the data you want to post as a gist.</p>
<p>$ gist (type a gist. <ctrl-c> to cancel, <ctrl-d> when done) { “foo“
: “bar“ } https://gist.github.com/9106765</p>
<p>The gist command will return the link to the gist just created. Gists
are created anonymously by default. You can login using the –login
switch. Once you do this, your gists will be linked to your account.</p>
<p>$ gist –login Obtaining OAuth2 access_token from github. GitHub
username: xrd GitHub password: 2-factor auth code: 787878 Success!
https://github.com/settings/applications</p>
<p>You can pipe text to the gist command to use the contents of that
file.</p>
<p>$ echo ‘{ “foo“ : “bar“ }’ | gist https://gist.github.com/9106799</p>
<p>You can also cat a file to gist.</p>
<p>$ cat MyJavaFile.java | gist https://gist.github.com/9345609</p>
<p>Gists are often used to show interesting or troublesome code and
there are times when you don’t want to display the entirety of a file.
In this case the command line grep tool can be a useful; grep searches
for a specific piece of code and with the right switches can include
several lines of context around that code inside a gist. This command
looks for the function myFunction inside the MyJavaFile.java file and
then prints the next 20 lines of context and stores it as a gist.</p>
<p>$ grep -A 20 myFunction MyJavaFile.java | gist
https://gist.github.com/9453069</p>
<p>Adding the -o switch automatically opens the gist inside your default
web browser. You can also copy the gist URL to the clipboard using the
-c switch. Or, you can copy the contents of your clipboard into a gist
using the -P switch.</p>
<p>There are many other fun features of the gist command. To learn more
run the gist command with the –help switch.</p>
<p>As gists are themselves repositories, you can use them for dual
purposes: for hosting code samples, code samples which are themselves
fully working and packaged applications inside a Git repository.</p>
<p>Gists as fully functioning apps</p>
<p>To demonstrate this ability, let’s build a simple Sinatra
application. Sinatra is a ruby library for creating dead-simple web
servers. A Sinatra program looks as simple as this:</p>
<p>require ‘sinatra’ get ‘/hi’ do “Hello World!“ end</p>
<p>Create a gist for this by visiting gist.github.com. Enter in the text
exactly as above and then choose public gist.</p>
<p>You now have a shareable gist of code, which anyone can use to
review. More importantly, this is an executable piece of code. To use
it, click into the “Clone this gist” box to the left of the body of
content. You’ll get a URL which looks something like this:</p>
<p>https://gist.github.com/8138797.git</p>
<p>Copy this and then enter a terminal program and enter this
command:</p>
<p>$ git clone https://gist.github.com/8138797.git $ cd 8138797</p>
<p>Now, you are inside the gist repository. If you look inside the
repository you’ll see a list of files, a list which right now numbers
only one file.</p>
<p>$ ls hi.rb</p>
<p>To run this code, enter ruby hi.rb</p>
<p>If you had not used Sinatra with ruby before, this will cause an
error. This program requires a library called “sinatra” and you have not
yet installed it. We could write a README, or add documentation into
this file itself. Another way to guarantee the user has the proper files
installed is to use a “Gemfile” which is a file that tells which
libraries are installed and from where. That sounds like the best
way:</p>
<p>$ printf “source ‘https://rubygems.org’</p>
<p>gem ‘sinatra’“ &gt; Gemfile</p>
<p>The bundle command (from the bundler gem) will install Sinatra and
the associated dependencies.</p>
<p>$ bundle Using rack (1.5.2) Using rack-protection (1.5.1) Using tilt
(1.4.1) Using sinatra (1.4.4) Using bundler (1.3.5) Your bundle is
complete! Use <code>bundle show 〔gemname〕</code> to see where a
bundled gem is installed.</p>
<p>Why did we do things this way? Because now we can add the Gemfile to
our repository locally, and then publish into our gist for sharing on
the web. Our repository now not only has the code, but a well know
manifest file which explains the necessary components when running the
code.</p>
<p>To publish our changes back into our gist from the command line, we
need to update the “remote” repository reference. When we first cloned
the repository we used the https link. If we are using SSH keys (and you
should be; read the section “When should I use SSH vs HTTPS?”) then we
need to switch to use the SSH URL format (git protocol). Run this
command:</p>
<p>$ git remote -v origin https://gist.github.com/8138797.git (fetch)
origin https://gist.github.com/8138797.git (push)</p>
<p>Your results will be slightly different, but this output displays our
remote repository; in other words, where we pull and push our code
changes. If you are familiar with the way that remotes work on GitHub
you can see that this is a read-only URL. We need to adjust these URLs
in our remote so that it points to the read-write remote URL. To do
that, remove the https:// part and add a git@. Then, change the first /
character after the gist.github.com URL to a : character. If your remote
was the same as above you would have this
git@gist.github.com:8138797.git. Then, in a terminal window run these
commands:</p>
<p>$ git remote rm origin $ git remote add origin
git@gist.github.com:8138797.git</p>
<p>Now you can push new content in via the command line as well as edit
files inside of GitHub.com. As you develop your app you have flexibility
in whichever way fits you best.</p>
<p>Now let’s take it further: what if we modified our application to use
the GitHub API, specifically to access information about gists for a
user?</p>
<p>Gists that render Gists</p>
<p>Let’s add to our application and use the octokit gem to pull all
public gists for any user we specify. Why would we want to make a gist
that displays other gists? Self-referential meta code is all the rage,
the modern day response to René Magritte’s famous work: “Ceci n’est pas
une pipe.”.〔1〕</p>
<p>Add a view index.erb at the root of our directory.</p>
<html>
<body>
User has &lt;%= count %&gt; public gists
</body>
</html>
<p>Add the octokit gem to our Gemfile:</p>
<p>gem “octokit“</p>
<p>Run bundle to install octokit. Then, modify our hi.rb app to look
like this:</p>
<p>require ‘sinatra’ require ‘octokit’ set :views, “.“ get ‘/:username’
do |username| user = Octokit.user username count = user.public_gists erb
:index, locals: { :count =&gt; count } end</p>
<p>Our filesystem should look like this, with three files.</p>
<p>$ ls -1 Gemfile hi.rb index.erb</p>
<p>Run bundle to install octokit and restart Sinatra by running ctrl-c,
and then ruby hi.rb. If you visit http://localhost:4567/xrd in your
browser, you will see the count of public gists for user xrd; modify the
username in the URL to any specify any GitHub username and you will see
their last five gists displayed.</p>
<p>Going deeper into the Gist API</p>
<p>The GitHub API uses hypermedia instead of basic resource driven APIs.
If you use a client like Octokit, the hypermedia details are hidden
behind an elegant ruby client. But, there is a benefit to understanding
how hypermedia works when you need to retrieve deeper information from
the GitHub API.</p>
<p>Most RESTful APIs come with a “sitemap”, generally a API reference
document which tells a user which endpoints to use. You view the
resources available from that API and then apply some HTTP verb to do
something to them. Hypermedia thinks of an API differently. Hypermedia
APIs describe themselves inside their responses using “affordances.”
What this means is that the API might respond like this:</p>
<p>{ “_links“: { “self“: { “href“:
“http://shop.oreilly.com/product/0636920030300.do“ } } “id“: “xrd“,
“name“: “Chris Dawson“ }</p>
<p>In this payload, you can see that there is an id (“xrd”) and a name
(“Chris Dawson”). Most APIs offer JSON responses, and this one does too.
This particular payload was forked from the HAL explanation at the HAL
Primer document and you can find a more detailed explanation of these
concepts there.</p>
<p>The important thing to note about Hypermedia APIs is that payloads
contain metadata about data itself and metadata about the possible
options of operating on the data. RESTful APIs typically provide a
mapping outside of the payload. You have to join the API sitemap with
the data in an ad-hoc way when using RESTful APIs; with Hypermedia APIs
your client can react to the payload itself correctly and intelligently
without knowing anything about a sitemap stored in human readable
documentation.</p>
<p>This loose coupling makes APIs and their clients flexible. In theory,
a Hypermedia API works intuitively with a Hypermedia aware client. If
you change the API, the client, as it understands Hypermedia, can react
and still work as expected. Using a RESTful API means that clients must
be updated (either a newer version of the client must be installed) or
the client code must be upgraded. Hypermedia APIs can alter their
backend and the client, as long as it is hypermedia-aware, can
automatically and dynamically determine the right way to access
information from the response itself. In other words, with a hypermedia
client the API backend can change and your client code should not need
to.</p>
<p>This is explained in great detail in the book Building Hypermedia
APIs with HTML5 and Node.</p>
<p>In the case of Octokit, navigating hypermedia looks like this:</p>
<p>Start at a resource, with code like user = Octokit.user “xrd“. This
begins the initialization of the client.</p>
<p>user now is an object filled with the actual data of the resource. In
this case, you could call a method like user.followers to see a meager
follower count.</p>
<p>user also has hypermedia references. You can see these by calling
user.rels. This retrieves the relationships described in the hypermedia
links. In this case, calling .rels shows a map of relationships,
displayed in ruby code like: #&lt;Sawyer::Relation::Map: 〔:avatar,
:self, :html, :followers, :following, :gists, :starred, :subscriptions,
:organizations, :repos, :events, :received_events〕&gt;</p>
<p>Using one of these relationships starts by keying into the
relationship hash and then using the get and data methods to request
that information from the GitHub API: followers =
user.rels〔:followers〕.get.data.</p>
<p>Once you call .get.data you will have a new followers object
populated with an array of the followers (paged if it exceeds 100
items).</p>
<p>Let’s extend our Sinatra app to retrieve actual data about the user’s
gists by using hypermedia references.</p>
<p>require ‘sinatra’ require ‘octokit’ set :views, “.“ helpers do def
h(text) Rack::Utils.escape_html(text) end end get ‘/:username’ do
|username| gists = Octokit.gists username, :per_page =&gt; 5 erb :index,
locals: { :gists =&gt; gists, username: username } end</p>
<p>The index.erb file contains code to iterate over each gist and pull
the content. You can see that our response object is an array of gists,
each which has an attribute called fields. This fields attribute
specifies the filenames available in each gist. If you reference that
filename against the files, the response includes a hypermedia ref
attribute. You can use this retreive the raw content using the Octokit
method .get.data.</p>
<html>
<body>
<h2>
User &lt;%= username %&gt;’s last five gists
</h2>
&lt;% gists.each do |g| %&gt; &lt;% g〔:files〕.fields.each do |f| %&gt;
<b>&lt;%= f %&gt;</b>: &lt;%= h
g〔:files〕〔f.to_sym〕.rels〔:raw〕.get.data %&gt; <br/> <br/> &lt;%
end %&gt; &lt;% end %&gt;
</body>
</html>
<p>Now we see the gists and the contents.</p>
<p>Summary</p>
<p>In this chapter we looked at gists and learned how they can be used
to share code snippets. We built a simple application and stored it as a
gist. This application retrieves data from the GitHub API using our
first higher level language client library (the Octokit library for
Ruby). We also went deeper into how Hypermedia works and how a client
library implements using Hypermedia metadata.</p>
<p>In the next chapter we will look at Gollum, the GitHub wiki. This
chapter provides an introduction to the Rugged Ruby library for
accessing Git repositories and the Ruby library for accessing
GitHub.</p>
<hr />
<ul>
<li>〔1〕 Explained best by Ben Zimmer
http://www.bostonglobe.com/ideas/2012/05/05/dude-this-headline-meta-dude-this-headline-meta/it75G5CSqi82NtoQHIucEP/story.html?camp=pm</li>
</ul>
<h6 id="阅读日期-2025年11月20日-2025年11月20日-共-1-天">阅读日期：
2025年11月20日-2025年11月20日 共： 1 天</h6>
<script src="https://giscus.app/client.js"
        data-repo="hbaolong/hbaolong.github.io"
        data-repo-id="R_kgDOLetDQg"
        data-category="General"
        data-category-id="DIC_kwDOLetDQs4CfLEl"
        data-mapping="url"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>
</body>
</html>
